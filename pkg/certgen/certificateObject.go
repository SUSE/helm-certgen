package certgen

import (
	"fmt"

	"github.com/cloudflare/cfssl/cli/genkey"
	"github.com/cloudflare/cfssl/csr"
	"github.com/cloudflare/cfssl/log"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/kubernetes/pkg/apis/certificates"
)

const (
	certificateCountry                = "US"
	certificateState                  = "Washington"
	certificateLocality               = "Seattle"
	certificateOrganizationName       = "Suse"
	certificateOrganisationalUnitName = "CaaSP"
	certAlgorithm                     = "rsa"
	defaultBitsLength                 = 2048
)

var (
	certificateUsages = []certificates.KeyUsage{
		certificates.UsageDigitalSignature,
		certificates.UsageServerAuth,
		certificates.UsageKeyEncipherment,
	}
	certificateGroups = []string{"system:authenticated"}
)

//CertificateObject hosts all the information about specific certificate
type CertificateObject struct {
	CertificateInfoObj *CertificateInfo
	CSR                *certificates.CertificateSigningRequest
	CSRSpec            *certificates.CertificateSigningRequestSpec
	CertKey            []byte
	Cert               []byte
}

func NewCertificateObject(certInfo *CertificateInfo) *CertificateObject {
	return &CertificateObject{
		CertificateInfoObj: certInfo,
	}
}

func (c *CertificateObject) CreateCertificate(name string) *certificates.CertificateSigningRequest {
	c.CSR = &certificates.CertificateSigningRequest{}
	c.CSR.Spec = *c.generateCSRSpec()
	c.CSR.Name = name
	return c.CSR
}

func (c *CertificateObject) UpdatedApproval() *certificates.CertificateSigningRequest {
	condition := certificates.CertificateSigningRequestCondition{
		Type: certificates.CertificateApproved,
		//Reason:         "Approved via helm certgen plugin",
		//Message:        "Generated by helm certgen plugin",
		Reason:         "KubectlApprove",
		Message:        "This CSR was approved by kubectl certificate approve.",
		LastUpdateTime: metav1.Now(),
	}
	c.CSR.Status.Conditions = append(c.CSR.Status.Conditions, condition)
	return c.CSR
}

func (c *CertificateObject) generateCSRSpec() *certificates.CertificateSigningRequestSpec {
	if c.CSRSpec == nil {
		c.CSRSpec = &certificates.CertificateSigningRequestSpec{}

		c.CSRSpec.Usages = certificateUsages
		c.CSRSpec.Groups = certificateGroups
	}
	csr, key, err := c.generateNewCert()
	if err != nil {
		fmt.Println("Error: ", err)
		return nil
	}
	c.CSRSpec.Request = csr
	c.CertKey = key
	return c.CSRSpec
}

func (c *CertificateObject) generateNewCert() (certCsr []byte, certKey []byte, err error) {
	// returns a new cert for hostnames, signed by the provided CA/key. The first hostname will be the CN, and all hostnames will go in SAN

	// create certificate request
	req := csr.CertificateRequest{
		CN:    c.CertificateInfoObj.Name,
		Hosts: c.CertificateInfoObj.Hosts,
		Names: []csr.Name{
			{
				C:  certificateCountry,
				ST: certificateState,
				L:  certificateLocality,
				O:  certificateOrganizationName,
				OU: certificateOrganisationalUnitName,
			},
		},
		KeyRequest: &csr.BasicKeyRequest{
			A: certAlgorithm,
			S: defaultBitsLength,
		},
	}
	log.Level = log.LevelError
	// validate and process certificate request
	g := &csr.Generator{Validator: genkey.Validator}

	return g.ProcessRequest(&req)
}
